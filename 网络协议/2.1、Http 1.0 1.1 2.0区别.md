https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A

# 一、简述什么是http协议

- ##### 1、http协议是应用层协议,Hyper Text Transfer Protocol（超文本传输协议），通常建立在tcp协议基础上的请求-响应协议。
- ##### 2、请求和响应消息以ASCII码文本形式传输。
- ##### 3、http协议自1991年建立以来，发展经过0.9、1.0、1.1、2.0版本
- ##### 4、http1.1是现在主要使用的协议版本，相对1.0他有几点改进。。。
    - 引入了**更多的缓存控制策略**If-Unmodified-Since, If-Match等
    - **带宽优化及网络连接的使用**，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206
    - **错误通知的管理**，新增了24个错误状态响应码，410（Gone）表示服务器上的某个资源被永久性的删除。
    - **Host头处理**，没有Host头域会报告一个错误（400 Bad Request）。
    - **支持长连接，keep-alive**，可以通过长连接复用Pipeling解决多次TCP连接浪费资源，在一次tcp连接中保活来传输更多数据，但是只能串行request请求，request上一次的未结束下一次不能开始造成**线头阻塞**。http2.0中多路复用可以做到并行请求，解决线头阻塞。
- ##### 5、http2.0是2015年由google推出，相对1.1有几点改进。。。
    - **二进制数据传输**
    - **多路复用**，
        - http1.1长连接复用虽然也能解决tcp频繁连接问题，但是产生新问题，线头阻塞。而2.0多路复用完美兼容。
        - 帧（frame）、流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。2.0
        - 通过帧和流的操作解决了http1.*中单次request数据不能穿插传输问题。
    - **header头压缩**
    - **服务器推送**
- ##### 6、http三大特点
    - **面向无连接的**：即每次连接只处理一个请求，客户端发起请求，并受到服务端响应后，立即关闭连接。当然http1.1的长连接、http2.0的多路复用在这方面做了一些拓展，用于频繁建立tcp连接的情况，节省tcp连接资源。
    - **媒体MIME-TYPE独立的**：即只要客户端、服务端知道MIME-TYPE媒体类型，任何形式数据都可以传输。当然http1.X是以ASCII码文本形式传输，http2.0用二进制方式传输。
    - **无状态** 无状态是指协议对于事务处理没有记忆能力，比如登录状态之类需要通过cookie辅助解决。
- ##### 7、request组成
    -  请求行（request line）:request-method、request-url、remote address。。
    -  请求头（header）：content-type/content-length/connection/cache-control/Host等
    -  空行
    -  请求数据（request body）：和header中content-type有关，
        -  application/x-www-form-urlencoded -> Form Data ：服务端用request.getParameter(name)获取参数
        -  application/json -> Request Payload：服务端用getRequestPayload获取
        
- ##### 8、response组成
    - 状态行
    - 消息报头（header）
    - 空行
    - 响应正文（response body）
    - ![image](https://note.youdao.com/yws/public/resource/7a8aab01b8d4aebb5b8c45ed842b6451/xmlnote/WEBRESOURCE0ff6d23d5bc0a2ff3b6d742d90683ea1/3832)
- ##### 9、request Method
    - 8种方式：GET/HEAD/POST/PUT/PATCH/DELETE/CONNECT/OPTIONS/TRACE 
    - 
|序号|方法|描述|
|:-    |:------|:-|
|1|GET（SELECT）|请求指定的页面信息，并返回实体主体。|
|2|HEAD（SELECT）|**类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头，比如是否支持断点续传等等**|
|3|POST（CREATE）|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。|
|4|PUT（UPDATE）|在服务器更新资源（客户端提供完整资源数据）从客户端向服务器传送的数据取代指定的文档的内容。|
|5|PATCH（UPDATE）|在服务器更新资源（客户端提供需要修改的资源数据）。|
|5|DELETE（DELETE）|请求服务器删除指定的页面。|
|6|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|
|7|OPTIONS|允许客户端查看服务器的性能。|
|8|TRACE|回显服务器收到的请求，主要用于测试或诊断。|
- ##### 10、HTTP 状态码分类
|分类|分类描述|
|:--|:--|
|1**|信息，服务器收到请求，需要请求者继续执行操作|
|2**|成功，操作被成功接收并处理|
|3**|重定向，需要进一步的操作以完成请求|
|4**|客户端错误，请求包含语法错误或无法完成请求|
|5**|服务器错误，服务器在处理请求的过程中发生了错误|
    - 100 继续操作、101切换协议
    - 200 请求成功
    - 301 重定向、永久移动，url直接变
    - 302 重定向、临时移动，url不变
    - 400 语法错误
    - 401 需身份认证
    - 403 服务器拒绝请求
    - 404 找不到页面
    - 405 request method方法被禁止
    - 500 服务器内部错误
    - 502 网关错误

# 二、HTTP的历史

早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。

![image](https://note.youdao.com/yws/public/resource/7a8aab01b8d4aebb5b8c45ed842b6451/xmlnote/WEBRESOURCEb31ae0c7e50ed80bbe64aea35d8a9ace/3631)

# 三、HTTP的基本优化
影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。
- 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。
- 延迟：
    - 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。
    - DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。
    - 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。

# 四、HTTP1.0和HTTP1.1的一些区别
- 1、**缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
- 2、**带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- 3、**错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
- 4、**Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
- 5、**长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
 

# 五、HTTP2.0和HTTP1.x的一些区别
- **1、二进制格式传输**（Binary Format），
    - HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。
    - 基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **2、多路复用**（MultiPlexing），
    - 在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
    - 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个request，对端可以通过帧中的标识知道属于哪个request。通过这个技术，可以避免 HTTP1.1中的线头阻塞问题，极大的提高传输性能。

- **3、header压缩**，
    - HTTP1.x的header带有大量文本形式信息，而且每次都要重复发送
    - 在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。
- 4、**服务端推送**（server push）
    - 在接到某个request请求后，主动推送相关资源
    - 可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。
    - Http/1.1 尝试优化资源时只能通过URI（data:[mediatype][;base64],data）的方式嵌入到页面中。
    ![image](https://note.youdao.com/yws/public/resource/7a8aab01b8d4aebb5b8c45ed842b6451/xmlnote/24160132D9FE413CAA696731E157F546/3726)

# 六、HTTP2.0的升级改造
- 1、前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。
- 2、当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书，NGINX配置HTTP2.0官方指南 https://www.nginx.com/blog/nginx-1-9-5/。
- 3、使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。


# 七、详说http2.0
### （1）HTTP2.0的多路复用和HTTP1.X中的长连接Connection:keep-alive复用有什么区别？
- HTTP/1.* 正常情况下，一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
- HTTP/1.1 长连接复用Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的**线头阻塞**；
    - 也就是说Http1.1 持久HTTP多次请求必须严格满足先进先出（FIFO）的队列顺序：发送请求，等待响应完成，再发送客户端队列中的下一个请求。
- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
具体如图：
![image](https://note.youdao.com/yws/public/resource/7a8aab01b8d4aebb5b8c45ed842b6451/xmlnote/WEBRESOURCE7e11bd68f995991a8c55fe6633202e94/3639)


### (2)HTTP2.0多路复用有多好？

- HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。  
- HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。


### (3)服务器推送到底是什么？
服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下

- 普通的客户端请求过程：

![image](https://note.youdao.com/yws/public/resource/7a8aab01b8d4aebb5b8c45ed842b6451/xmlnote/WEBRESOURCE4f9f8b5dce6415247bcebb245cdb8d7d/3641)
- 服务端推送的过程：

![image](https://note.youdao.com/yws/public/resource/7a8aab01b8d4aebb5b8c45ed842b6451/xmlnote/WEBRESOURCEc061857a63349db41c9a1f893c9a9dfd/3643)

### (4)为什么需要头部压缩？
假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍
 
