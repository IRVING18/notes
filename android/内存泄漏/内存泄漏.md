# 内存泄漏
> hencoder 20节

## 一、GC Root 
> GC Root持有的对象不会被释放，从而造成内存泄漏。

- 运行中的线程
- static
- 本地代码的引用

### 举例：
- AysncTask 容易造成内存泄漏的主要原因是因为，他里边有线程，而线程是一种GC Root。
    - 当在AysncTask执行中，Activity关闭了，而AysncTask内部线程是**GCroot**，并且因为MyAysncTask是MainActvity的内部类，所以MyAysncTask会持有MainActivity的对象，直到线程结束，就会出现内存泄漏。
- AysncTask 如果里边的线程没有特别长的执行时间，是不需要特别注意的。因为如果线程只是再Activity关闭之后几秒就执行完了，他就释放了。所以不用特别处理，只有当其中线程执行时间特别长的时候需要特殊处理。
```java
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        new MyAsyncleTask().execute();
    }

    class MyAsyncleTask extends AsyncTask {

        @Override
        protected Object doInBackground(Object[] objects) {
            return null;
        }
    }
```
## 二、java内存分配策略
Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。

- 静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
- 栈区 ：当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- 堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。

**栈与堆的区别：**

在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。

堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。
